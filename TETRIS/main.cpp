# include "iGraphics.h"# include <windows.h>#include <mmsystem.h>#define column_no 10#define row_no    20/* GAMESTATE values */#define GAMEINTRO    -2#define GAMELOADPERA -1#define GAMEMENU      0#define GAMEPLAYING   1#define GAMEOVER      2#define GAMESCORE     3#define GAMERECORD    4#define GAMEHIGHSCORE   5#define GAMEHELP        6#define GAMEMENUEXIT        7#define GAMEPAUSEMENU       8#define CHEAT/* MOTHER OF ALL VARIABLES */int GAMESTATE = GAMEINTRO;/* game board */int board_x = 214, board_y = 66;int board_dx, board_dy;int block_width = 28;int wall_width = 1;int gameCellX[row_no][column_no], gameCellY[row_no][column_no];struct gameBoardCellData{    int occupied;    int blip;    int R, G, B;} gameBoard[row_no+3][column_no];/* next window */int next_x, next_y;int nextCellX[4][5], nextCellY[4][5];int BoardGap = 30;int next_dx, next_dy, nextBlock_len = 22;/* Shape */int shapeIndex, nextShapeIndex;struct object{    int blockRow[4], blockCol[4];    int orientation;} shape[8];/* line clear */int bombfell_x = -1;int bombfell_y = -1;int bombcolor = -1;int AnimateTimer = 0, destroyRow[row_no];const int Diag_no = row_no + column_no - 1 - 2 - 2;int destroyDiagF[Diag_no];   /// [i][j] belongs to diagonal i-j+7;int destroyDiagB[Diag_no];   /// [i][j] belongs to diagonal i+j-2;int bonus = 50;/* Time */const int Period = 20;int userPause = 0;long long gameTime = 0, prevDropTime = 0, shapesDropped = 0;long long prevBombTime = 0, bombTimeGap = 1000*60;int loadingPeriod = 2000;/* Cursor position */int Mx, My;/* Menu and bars */int X = 295,Y = 125;int menuBardx = 200,menuBardy = 60;int menuBarGap = 25;int popUpSize = 7;/* Pause bars */int pauseBarX = 266, pauseBarY = 310;/* Intro animation */int boro = 11, choto = 4;int R = 0, G = 0, B = 0;int RP = 0, GP = 0, BP = 0;int titleX = 395, titleY = 429;int subtitleX = 384, subtitleY = 288;int done = 0;int fnt = 2;int gap = 100;/* GAMEOVER color change rate */int goRrate = 5, goR = 255;/* Converts the int curLevel to string in strLevel[]. */void convertToString(int x, char *s){    if(x == 0){        strcpy(s, "0");        return;    }    int i, j;    for(i = 0; x; i++){        s[i] = (x%10) + '0';        x /= 10;    }    s[i] = 0;    for(j = 0, --i; j <= i; j++, i--){        char temp = s[j];        s[j] = s[i];        s[i] = temp;    }}double dis(double x1, double y1, double x2, double y2){    return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));}# include "Retro-fonts.h"# include "3D Blocks.h"# include "NextShapeScreen.h"# include "LevelControl.h"# include "ShapeMovement.h"# include "Scores.h"# include "lineClear.h"# include "HighScoreControl.h"# include "menuControls.h"# include "GameFlow.h"/* Tries to drop down the current levitating/falling shape. */void dropDown(int calledFromTimer){    if(GAMESTATE != GAMEPLAYING) return;    if(userPause || AnimateTimer > 0) return;    if(calledFromTimer && gameTime-prevDropTime < levelTime[curLevel]) return;    int i, j, canDrop = 1, tempR, tempC;    // Check if the shape can be moved down    for(i = 0; i < 4; i++){        tempR = shape[shapeIndex].blockRow[i];        tempC = shape[shapeIndex].blockCol[i];        if(tempR-1 < 0) canDrop = 0; // bottom of the gameBoard        else if(tempR-1>=0 && tempR-1<row_no && gameBoard[tempR-1][tempC].occupied != -1) canDrop = 0; // a block is present below    }    // if canDrop, drop down all the blocks of the shape    // else the gameBoard cells where the shape has fallen needs to contain    // the information that these cells are occupied by shapeIndex    // and then a new shape is needed.    if(canDrop){        for(i = 0; i < 4; i++) shape[shapeIndex].blockRow[i]--;        prevDropTime = gameTime;    }    else{        if(shapeIndex == 7)
        {
            bombfell_x = shape[shapeIndex].blockCol[0];
            bombfell_y = shape[shapeIndex].blockRow[0];
        }        processForGameOver();        for(i = 0; i < 4; i++){            tempR = shape[shapeIndex].blockRow[i];            tempC = shape[shapeIndex].blockCol[i];            gameBoard[tempR][tempC].occupied = shapeIndex;        }        createShapes(); // virtually creates and positions all shapes at the top        shapeIndex = nextShapeIndex;        if(shapeIndex == 7) prevBombTime = gameTime;        if(GAMESTATE == GAMEPLAYING){            if(gameTime - prevBombTime > bombTimeGap)                nextShapeIndex = rand() % 8;            else                nextShapeIndex = rand() % 7;        }    }}void animateIntro(){    if(R<255 && G<255 && B<255){ R += 2; G += 2; B += 2; }    else if(RP<255 && GP<255 && BP<255){ RP += 2; GP += 2; BP += 2; }    else if(!done) done = 1;}void timerAction(){    int screen_pos_x = glutGet((GLenum) GLUT_WINDOW_X);    int screen_pos_y = glutGet((GLenum) GLUT_WINDOW_Y);    POINT p;    GetCursorPos(&p);    Mx = p.x - screen_pos_x;    My = 700 - (p.y - screen_pos_y);    if(GAMESTATE == GAMEINTRO){        animateIntro();    }    if(GAMESTATE == GAMELOADPERA){        gameTime += Period;    }    if(GAMESTATE == GAMEPLAYING){        LineClear();        if(!(userPause || AnimateTimer > 0)){            gameTime += Period;            levelUp();            dropDown(1);        }    }    if(GAMESTATE == GAMEOVER){        if(goR > 255 || goR < 120) goRrate *= -1;        goR += goRrate;    }}void Dots(int n){    int X = 344, Y = 313;    int radius = 6, gap = 49;    if(n >= 1) iFilledCircle(X, Y, radius);    if(n >= 2) iFilledCircle(X+gap, Y, radius);    if(n >= 3) iFilledCircle(X+2*gap, Y, radius);}void drawLoadingDots(){    if(gameTime > loadingPeriod){        GAMESTATE = GAMEMENU;        PlaySound(TEXT("DOCTOR VOX - Hero.wav"), NULL, SND_LOOP | SND_ASYNC);        return;    }    int x = gameTime/(loadingPeriod/8);    x %= 4;    Dots(x);}void drawIntro(){    iSetColor(R, G, B);	RetroMiddleText(titleX, titleY, "PERATRICKS", boro);	iSetColor(RP, GP, BP);	RetroMiddleText(subtitleX, subtitleY, "PERAR KONO SHESH NAI", choto);	if(done){        iSetColor(140, 140, 140);        RetroMiddleText(subtitleX, subtitleY-gap, "PRESS ENTER TO CONTINUE", fnt);	}}
void iDraw() {
	iClear();//	iSetColor(0, 230, 0);//	iFilledCircle(Mx, My, 2);	if(GAMESTATE == GAMEINTRO){        drawIntro();	}	if(GAMESTATE == GAMELOADPERA){        iSetColor(255, 50, 70);        RetroMiddleText(395, 410, "LOADING PERA", 7);        drawLoadingDots();	}	if(GAMESTATE == GAMEMENU){        drawPERATRICKS();        drawMenu(X,Y,menuBardx,menuBardy,menuBarGap);	}	if(GAMESTATE == GAMEPLAYING){        playGame();	}	if(GAMESTATE == GAMEOVER){        printGameOver();	}	if(GAMESTATE == GAMESCORE){        printScore();	}	if(GAMESTATE == GAMERECORD){        takeUserName();	}	if(GAMESTATE == GAMEHIGHSCORE){        drawHighScore();	}	if(GAMESTATE == GAMEMENUEXIT || GAMESTATE == GAMEPAUSEMENU){        drawExit();	}	if(GAMESTATE == GAMEHELP){        drawHelp();	}}

/*
	function iMouseMove() is called when the user presses and drags the mouse.
	(mx, my) is the position where the mouse pointer is.
	*/
void iMouseMove(int mx, int my) {
}

/*
	function iMouse() is called when the user presses/releases the mouse.
	(mx, my) is the position where the mouse pointer is.
	*/
void iMouse(int button, int state, int mx, int my) {
	if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
        if(GAMESTATE == GAMEMENU) checkMenuOption(mx, my);        if(GAMESTATE == GAMEPLAYING) checkPauseOption(mx, my);        if(GAMESTATE == GAMEMENUEXIT || GAMESTATE == GAMEPAUSEMENU) checkExitOption(mx, my);        if(GAMESTATE == GAMEHIGHSCORE || GAMESTATE == GAMEHELP) checkToMenuOption(mx, my);	}
	if (button == GLUT_RIGHT_BUTTON && state == GLUT_DOWN) {

	}
}


void iKeyboard(unsigned char key) {
	/* Taking userName from the user */	if(GAMESTATE == GAMERECORD){        if(key == '\b'){            len--;            if(len < 0) len = 0;            userName[len] = 0;        }        else if(len < MAX_NAME_LEN && key != '\r' && key != '\n'){            userName[len++] = key;            userName[len] = 0;        }	}	/* User presses ENTER in GAMESTATE:	   GAMEMENU:  pressing ENTER will not do any change	   GAMEHIGHSCORE: pressing ENTER will take him back to GAMEMENU. Same will happen	                  for GAMEHELP.       GAMEPLAYING: pressing ENTER while playing the game will not have any effect       GAMEOVER: pressing ENTER will show user his/her score.       GAMESCORE: pressing ENTER will either prompt the user for his/her name if he/she                  has a new record, else will take him/her to the menu        GAMERECORD: pressing ENTER will save the username from the user                    and then take him/her to menu */	if(key == '\r'){        if(GAMESTATE == GAMEINTRO && done){            GAMESTATE = GAMELOADPERA;            gameTime = 0;            PlaySound(NULL, NULL, 0);            return;        }        if(GAMESTATE == GAMEHIGHSCORE || GAMESTATE == GAMEHELP){            GAMESTATE = GAMEMENU;//            PlaySound(TEXT("DOCTOR VOX - Hero.wav"), NULL, SND_LOOP | SND_ASYNC);            return;        }        if(GAMESTATE == GAMEOVER){            GAMESTATE = GAMESCORE;            return;        }        if(GAMESTATE == GAMESCORE){            if(isNewRecord() != -1) GAMESTATE = GAMERECORD;            else GAMESTATE = GAMEMENU;            PlaySound(TEXT("DOCTOR VOX - Hero.wav"), NULL, SND_LOOP | SND_ASYNC);            return;        }        if(GAMESTATE == GAMERECORD){            if(len == 0) return;            updateHighScore();            loadHighScores();            GAMESTATE = GAMEHIGHSCORE;            return;        }	}	if(key == ' '){        if(GAMESTATE == GAMEPLAYING) userScore += instantDrop();    }#ifdef CHEAT	if(key == 'o'){        nextShapeIndex = 6;    }    if(key == 'i'){        nextShapeIndex = 0;    }    if(key == 't'){        nextShapeIndex = 1;    }    if(key == 'j'){        nextShapeIndex = 2;    }    if(key == 'l'){        nextShapeIndex = 3;    }    if(key == 's'){        nextShapeIndex = 4;    }    if(key == 'z'){        nextShapeIndex = 5;    }	if (key == 'p'){
		if(GAMESTATE == GAMEPLAYING) userPause ^= 1;
	}	if(key == 'b'){        nextShapeIndex = 7;	}	if(key == 'h'){        userScore += 1000;	}//	if(key == 'x'){//        curLevel = 10;//	}    if (key == 'e'){
		/* Stop game to exit to main menu */
	}#endif // CHEAT
}

/*
	function iSpecialKeyboard() is called whenver user hits special keys like-
	function keys, home, end, pg up, pg down, arraows etc. you have to use
	appropriate constants to detect them. A list is:
	GLUT_KEY_F1, GLUT_KEY_F2, GLUT_KEY_F3, GLUT_KEY_F4, GLUT_KEY_F5, GLUT_KEY_F6,
	GLUT_KEY_F7, GLUT_KEY_F8, GLUT_KEY_F9, GLUT_KEY_F10, GLUT_KEY_F11, GLUT_KEY_F12,
	GLUT_KEY_LEFT, GLUT_KEY_UP, GLUT_KEY_RIGHT, GLUT_KEY_DOWN, GLUT_KEY_PAGE UP,
	GLUT_KEY_PAGE DOWN, GLUT_KEY_HOME, GLUT_KEY_END, GLUT_KEY_INSERT
	*/
void iSpecialKeyboard(unsigned char key) {

	if (key == GLUT_KEY_END) {
		exit(0);
	}    if(key == GLUT_KEY_DOWN){        if(GAMESTATE == GAMEPLAYING){            dropDown(0);            userScore++;        }    }	if(key == GLUT_KEY_RIGHT){        moveLaterally(1);	}	if(key == GLUT_KEY_LEFT){        moveLaterally(-1);	}    if(key == GLUT_KEY_UP){        srand(time(0));        struct object *op = &shape[shapeIndex];        Rotate(op, shapeIndex);	}}


int main() {
	//place your own initialization codes here.    srand(time(0));    LoadFonts();    fillLevelUps();    PlaySound(TEXT("ominous intro.wav"), NULL, SND_LOOP | SND_ASYNC);    iSetTimer(Period, timerAction);
	iInitialize(800, 700, "demo");
	return 0;
}
