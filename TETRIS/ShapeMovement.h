#ifndef SHAPE_MOVEMENT_Hvoid dropDown(int calledFromTimer);/* moves the piece left or right. dir == -1 means left, dir == 1 means right */void moveLaterally(int dir){    if(GAMESTATE != GAMEPLAYING) return;    if(userPause || AnimateTimer > 0) return;    srand(time(0));    int i, j, canMove = 1, tempR, tempC;    for(i = 0; i < 4; i++){        tempR = shape[shapeIndex].blockRow[i];        tempC = shape[shapeIndex].blockCol[i];        if(tempC+dir >= column_no || tempC+dir < 0) canMove = 0;        else if(tempR>=0 && tempR<row_no && gameBoard[tempR][tempC+dir].occupied != -1) canMove = 0;    }    if(canMove)     for(i = 0; i < 4; i++)        shape[shapeIndex].blockCol[i] += dir;}int instantDrop(){    if(GAMESTATE != GAMEPLAYING) return 0;    if(userPause || AnimateTimer > 0) return 0;    int shift, i;    int found = 0;    for(shift = 0; shift<25; shift++)    {        for(i = 0; i < 4; i++)        {            int tempRow = shape[shapeIndex].blockRow[i] - shift - 1;            int tempCol = shape[shapeIndex].blockCol[i];            if(tempRow < 0 || gameBoard[tempRow][tempCol].occupied > -1)                found = 1;        }        if(found == 1)            break;    }    for(i = 0; i < 4; i++){        shape[shapeIndex].blockRow[i] -= shift;    }    prevDropTime = gameTime;    if(shapeIndex != 7)        dropDown(0);    return shift;}///////////////////////////// ROTATION BY UPOBIR /////////////////////////////int valid(int rowpos[], int colpos[]){    int flag = 1;    for(int i = 0; i<4; i++)    {        if(rowpos[i] < 0 || rowpos[i] >= row_no+3 || colpos[i] < 0 || colpos[i] >= column_no)     ///CHECK        {            flag = 0;            break;        }        if(gameBoard[rowpos[i]][colpos[i]].occupied != -1)           ///CHECK        {            flag = 0;            break;        }    }    return flag;}void Rotate(struct object *shape, int shape_index){    if(userPause || AnimateTimer > 0) return;    if(shape_index == 6)             //O is ignored        return;    int rowpos[4];    int colpos[4];    int kicklimit;    int change = 0;    if(shape_index == 0)             //I is handles one way, the rest another    {        int rshift, cshift;        switch(shape->orientation)                  ///CHECK        {        case 0://            cerr<<"o";            rowpos[0] = shape->blockRow[2];       ///CHECK THESE AND BELOW            colpos[0] = shape->blockCol[2]+1;            rshift = 0;            cshift = -1;            break;        case 1:            rowpos[0] = shape->blockRow[2]-1;            colpos[0] = shape->blockCol[2];            rshift = +1;            cshift = 0;            break;        case 2:            rowpos[0] = shape->blockRow[2];            colpos[0] = shape->blockCol[2]-1;            rshift = 0;            cshift = +1;            break;        case 3:            rowpos[0] = shape->blockRow[2]+1;            colpos[0] = shape->blockCol[2];            rshift = -1;            cshift = 0;            break;        default:            break;        }        for(int i = 1; i<4; i++)        {            rowpos[i] = rowpos[0] + rshift*i;            colpos[i] = colpos[0] + cshift*i;        }        kicklimit = 2;    }    else    {        for(int i = 0; i<4; i++)        {            colpos[i] = (shape->blockRow[i] - shape->blockRow[1]) + shape->blockCol[1];            rowpos[i] = -(shape->blockCol[i] - shape->blockCol[1]) + shape->blockRow[1];        }        kicklimit = 1;    }    if(valid(rowpos, colpos) == 1)    {        change = 1;    }    else    {        for(int i = 1; i<=kicklimit && change == 0; i++)        {            for(int j = 0; j<4; j++)                rowpos[j] += i;            if(valid(rowpos, colpos) == 1)            {                change = 1;                break;            }            for(int j = 0; j<4; j++)                rowpos[j] -= i;        }        for(int i = 1; i<=kicklimit && change == 0; i++)        {            for(int j = 0; j<4; j++)                colpos[j] -= i;            if(valid(rowpos, colpos) == 1)            {                change = 1;                break;            }            for(int j = 0; j<4; j++)                colpos[j] += i;        }        for(int i = 1; i<=kicklimit && change == 0; i++)        {            for(int j = 0; j<4; j++)                colpos[j] += i;            if(valid(rowpos, colpos) == 1)            {                change = 1;                break;            }            for(int j = 0; j<4; j++)                colpos[j] -= i;        }    }    if(change == 1)    {        shape->orientation = (shape->orientation + 1) % 4;          ///CHECK        for(int i = 0; i<4; i++)        {            shape->blockRow[i] = rowpos[i];                         ///CHECK            shape->blockCol[i] = colpos[i];                         ///CHECK        }    }    else        return;}///////////////////////////////////////////////////////////////////////////////////////#endif // SHAPE_MOVEMENT_H